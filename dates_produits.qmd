---
title: "Disponibilité des images ASTER et LANDSAT sur la période [2016-2024]"
format: 
  html:
    fig-width: 25
    fig-height: 25
---

```{r error=TRUE, warning=FALSE, message=FALSE}
#| echo: false

# Charger les packages nécessaires
library(readxl)
library(tidyverse)
library(shiny)
library(plotly)

# lire le fichier contenant les metadonnées LANDSAT
landsat_metadata<- readxl::read_excel(
  "./data/pourcentage_de_nuages_landsat8.xlsx"
)[-1] |>
  # filter pour ne retenir que les images avec -10% de nuages
  dplyr::filter(pct_nuage<10)

# Extraire la date des images LANDSAT dans le dataframe `landsat_metadata`
landsat_dates<- base::data.frame(Date = landsat_metadata$dateprod, Produit = "LANDSAT")

# Lire le fichier contenat les dates LANDSAT
aster_dates<- utils::read.csv(
  "./data/ASTER_dates.csv"
) |>
  # supprimer les doublons
  dplyr::mutate(Produit = "ASTER") |>
  dplyr::distinct()

# Générer une séquence de dates sur la période 2016-2024 au pas de temps journalier.
dates_vect<- base::seq.Date(
  from = base::as.Date("2016-01-01"),
  to = base::as.Date("2024/12/31"),
  by = "day"
)

# concantener les tables LANDSAT et ASTER pour n'en faire qu'une seule table
dates_products<- dplyr::bind_rows(landsat_dates, aster_dates) |>
  dplyr::mutate(Date = base::as.Date(Date))


## Créer un dataframe avec une seule colonne correspondant au vecteur de dates créée plus haut
dates_df<- tibble::tibble(Date = dates_vect)

#* effectuer une jointure `full_join` de la table `dates_df` contenant la séquence de dates
#* journalières du `01/01/2016` au `31/03/2024` avec la table contenant les dates LANDSAT
#* et ASTER. Toutes les dates où il n'y a pas d'images ASTER ou LANDSAT aura des valeurs NA,
#*  qui seront remplacé par le caractère vide `("")` pour la visualisation

# jointure
final_df<- dplyr::full_join(dates_df, dates_products, by = "Date")

## Tracer le graphique des dates
final_df<- dplyr::mutate(
  final_df, Annee=lubridate::year(Date),
  Mois=lubridate::month(Date),
  Mois = dplyr::case_when(
    Mois == 1 ~ "Janvier", Mois == 2 ~ "Février", Mois == 3 ~ "Mars",
    Mois == 4 ~ "Avril", Mois == 5 ~ "Mai", Mois == 6 ~ "Juin",
    Mois == 7 ~ "Juillet", Mois == 8 ~ "Août", Mois == 9 ~ "Septembre",
    Mois == 10 ~ "Octobre", Mois == 11 ~ "Novembre", Mois == 12 ~ "Décembre"
  ),
  Mois = base::factor(
    Mois, levels=c(
      "Janvier", "Février", "Mars", "Avril", "Mai", "Juin",
      "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"
    )
  ),
  hauteur=dplyr::case_when(base::is.na(Produit)~0, TRUE~25),
  Produit=dplyr::case_when(base::is.na(Produit)~NA, TRUE~Produit)
)

scatter<- final_df |>
  na.omit() |>
  ggplot() +
  geom_point(
    aes(x=Mois, y=Date, fill=Produit), color="gray",  size = 3, 
    shape = 22, position=position_dodge(width=.1)
  ) +
  scale_y_date(date_breaks = "1 year", date_labels="%Y", expand=c(0.01, 0.01))

# transformer le graph ggplot en graph iteractive
ggplotly(scatter)
```
